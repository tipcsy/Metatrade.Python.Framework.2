"""
MACD-based trend analysis engine for multiple timeframes.

This module provides comprehensive MACD (Moving Average Convergence Divergence)
analysis with multi-timeframe support, signal generation, and trend detection.
"""

from __future__ import annotations

import asyncio
import time
import numpy as np
from collections import deque, defaultdict
from dataclasses import dataclass
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, List, Optional, Callable, Set, Tuple
import threading

from core.config.settings import Settings
from core.exceptions import IndicatorError, DataValidationError
from core.logging import get_logger
from core.data.models import OHLCData, TrendAnalysis, TrendDirection
from core.data import get_buffer_manager, get_event_publisher
from core.tasks import get_task_manager

logger = get_logger(__name__)


@dataclass
class MACDValues:
    """MACD indicator values."""
    macd_line: float
    signal_line: float
    histogram: float
    fast_ema: float
    slow_ema: float
    timestamp: datetime


@dataclass
class MACDConfig:
    """MACD configuration parameters."""
    fast_period: int = 12
    slow_period: int = 26
    signal_period: int = 9
    use_exponential: bool = True
    min_periods: int = 34  # slow_period + signal_period


class TrendSignal:
    """Represents a trend signal generated by MACD analysis."""

    def __init__(
        self,
        signal_type: str,
        strength: float,
        confidence: float,
        timestamp: datetime,
        price: float,
        macd_values: MACDValues,
        conditions: Dict[str, bool],
    ):
        self.signal_type = signal_type  # 'buy', 'sell', 'hold'
        self.strength = strength  # 0.0 to 1.0
        self.confidence = confidence  # 0.0 to 1.0
        self.timestamp = timestamp
        self.price = price
        self.macd_values = macd_values
        self.conditions = conditions  # Signal conditions met

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            'signal_type': self.signal_type,
            'strength': self.strength,
            'confidence': self.confidence,
            'timestamp': self.timestamp.isoformat(),
            'price': self.price,
            'macd_line': self.macd_values.macd_line,
            'signal_line': self.macd_values.signal_line,
            'histogram': self.macd_values.histogram,
            'conditions': self.conditions,
        }


class MACDCalculator:
    """
    High-performance MACD calculator with incremental updates.

    Features:
    - Exponential moving average calculation
    - Incremental updates for real-time processing
    - Memory-efficient circular buffers
    - Multi-period support
    """

    def __init__(self, config: MACDConfig):
        self.config = config

        # Price history for EMA calculation
        self.prices = deque(maxlen=max(config.slow_period * 2, 200))

        # EMA states
        self.fast_ema: Optional[float] = None
        self.slow_ema: Optional[float] = None
        self.signal_ema: Optional[float] = None

        # EMA multipliers (calculated once)
        self.fast_multiplier = 2 / (config.fast_period + 1)
        self.slow_multiplier = 2 / (config.slow_period + 1)
        self.signal_multiplier = 2 / (config.signal_period + 1)

        # MACD line history for signal calculation
        self.macd_history = deque(maxlen=config.signal_period * 2)

        # Calculation state
        self.periods_processed = 0
        self.is_ready = False

    def update(self, price: float, timestamp: datetime) -> Optional[MACDValues]:
        """
        Update MACD with new price.

        Args:
            price: New price value
            timestamp: Price timestamp

        Returns:
            MACDValues if calculation is ready, None otherwise
        """
        self.prices.append(price)
        self.periods_processed += 1

        # Calculate EMAs
        if self.fast_ema is None:
            # Initialize with first price
            self.fast_ema = price
            self.slow_ema = price
        else:
            # Update EMAs incrementally
            self.fast_ema = (price - self.fast_ema) * self.fast_multiplier + self.fast_ema
            self.slow_ema = (price - self.slow_ema) * self.slow_multiplier + self.slow_ema

        # Calculate MACD line
        macd_line = self.fast_ema - self.slow_ema
        self.macd_history.append(macd_line)

        # Calculate signal line
        if self.signal_ema is None:
            self.signal_ema = macd_line
        else:
            self.signal_ema = (macd_line - self.signal_ema) * self.signal_multiplier + self.signal_ema

        # Calculate histogram
        histogram = macd_line - self.signal_ema

        # Check if we have enough periods for reliable signals
        if not self.is_ready and self.periods_processed >= self.config.min_periods:
            self.is_ready = True
            logger.debug("MACD calculator is ready for signal generation")

        return MACDValues(
            macd_line=macd_line,
            signal_line=self.signal_ema,
            histogram=histogram,
            fast_ema=self.fast_ema,
            slow_ema=self.slow_ema,
            timestamp=timestamp,
        )

    def get_macd_history(self, periods: int) -> List[float]:
        """Get recent MACD line history."""
        return list(self.macd_history)[-periods:] if len(self.macd_history) >= periods else []

    def reset(self) -> None:
        """Reset calculator state."""
        self.prices.clear()
        self.macd_history.clear()
        self.fast_ema = None
        self.slow_ema = None
        self.signal_ema = None
        self.periods_processed = 0
        self.is_ready = False


class MACDSignalGenerator:
    """
    MACD signal generation with multiple signal types.

    Features:
    - Signal line crossovers
    - Zero line crossovers
    - Divergence detection
    - Momentum analysis
    - Confidence scoring
    """

    def __init__(self, config: MACDConfig):
        self.config = config
        self.macd_history: List[MACDValues] = []
        self.price_history: List[float] = []
        self.signal_history: List[TrendSignal] = []

        # Signal detection parameters
        self.min_crossover_strength = 0.3
        self.divergence_lookback = 10
        self.momentum_threshold = 0.5

    def analyze_signal(
        self,
        current_macd: MACDValues,
        current_price: float,
        previous_macd: Optional[MACDValues] = None,
    ) -> Optional[TrendSignal]:
        """
        Analyze MACD values for signal generation.

        Args:
            current_macd: Current MACD values
            current_price: Current price
            previous_macd: Previous MACD values

        Returns:
            TrendSignal if signal detected, None otherwise
        """
        # Store history
        self.macd_history.append(current_macd)
        self.price_history.append(current_price)

        # Keep limited history
        if len(self.macd_history) > 100:
            self.macd_history = self.macd_history[-50:]
            self.price_history = self.price_history[-50:]

        if previous_macd is None or len(self.macd_history) < 3:
            return None

        # Detect various signal types
        signals = []

        # 1. Signal line crossover
        crossover_signal = self._detect_signal_crossover(current_macd, previous_macd, current_price)
        if crossover_signal:
            signals.append(crossover_signal)

        # 2. Zero line crossover
        zero_crossover = self._detect_zero_crossover(current_macd, previous_macd, current_price)
        if zero_crossover:
            signals.append(zero_crossover)

        # 3. Divergence signals
        divergence_signal = self._detect_divergence(current_price)
        if divergence_signal:
            signals.append(divergence_signal)

        # 4. Momentum signals
        momentum_signal = self._detect_momentum_change(current_macd, current_price)
        if momentum_signal:
            signals.append(momentum_signal)

        # Return strongest signal
        if signals:
            best_signal = max(signals, key=lambda s: s.strength * s.confidence)
            self.signal_history.append(best_signal)
            return best_signal

        return None

    def _detect_signal_crossover(
        self,
        current: MACDValues,
        previous: MACDValues,
        price: float,
    ) -> Optional[TrendSignal]:
        """Detect MACD line crossing signal line."""
        # Check for crossover
        macd_above_prev = previous.macd_line <= previous.signal_line
        macd_above_curr = current.macd_line > current.signal_line

        macd_below_prev = previous.macd_line >= previous.signal_line
        macd_below_curr = current.macd_line < current.signal_line

        if macd_above_prev and macd_above_curr:
            # Bullish crossover
            strength = min(abs(current.macd_line - current.signal_line), 1.0)
            confidence = self._calculate_crossover_confidence(current, 'bullish')

            conditions = {
                'macd_above_signal': True,
                'bullish_crossover': True,
                'sufficient_strength': strength >= self.min_crossover_strength,
            }

            if conditions['sufficient_strength']:
                return TrendSignal(
                    signal_type='buy',
                    strength=strength,
                    confidence=confidence,
                    timestamp=current.timestamp,
                    price=price,
                    macd_values=current,
                    conditions=conditions,
                )

        elif macd_below_prev and macd_below_curr:
            # Bearish crossover
            strength = min(abs(current.signal_line - current.macd_line), 1.0)
            confidence = self._calculate_crossover_confidence(current, 'bearish')

            conditions = {
                'macd_below_signal': True,
                'bearish_crossover': True,
                'sufficient_strength': strength >= self.min_crossover_strength,
            }

            if conditions['sufficient_strength']:
                return TrendSignal(
                    signal_type='sell',
                    strength=strength,
                    confidence=confidence,
                    timestamp=current.timestamp,
                    price=price,
                    macd_values=current,
                    conditions=conditions,
                )

        return None

    def _detect_zero_crossover(
        self,
        current: MACDValues,
        previous: MACDValues,
        price: float,
    ) -> Optional[TrendSignal]:
        """Detect MACD line crossing zero line."""
        # Check for zero crossover
        if previous.macd_line <= 0 and current.macd_line > 0:
            # Bullish zero crossover
            strength = min(abs(current.macd_line), 1.0)
            confidence = self._calculate_zero_crossover_confidence(current, 'bullish')

            return TrendSignal(
                signal_type='buy',
                strength=strength,
                confidence=confidence,
                timestamp=current.timestamp,
                price=price,
                macd_values=current,
                conditions={
                    'zero_crossover_bullish': True,
                    'macd_above_zero': current.macd_line > 0,
                },
            )

        elif previous.macd_line >= 0 and current.macd_line < 0:
            # Bearish zero crossover
            strength = min(abs(current.macd_line), 1.0)
            confidence = self._calculate_zero_crossover_confidence(current, 'bearish')

            return TrendSignal(
                signal_type='sell',
                strength=strength,
                confidence=confidence,
                timestamp=current.timestamp,
                price=price,
                macd_values=current,
                conditions={
                    'zero_crossover_bearish': True,
                    'macd_below_zero': current.macd_line < 0,
                },
            )

        return None

    def _detect_divergence(self, current_price: float) -> Optional[TrendSignal]:
        """Detect price-MACD divergence."""
        if len(self.macd_history) < self.divergence_lookback:
            return None

        recent_macd = self.macd_history[-self.divergence_lookback:]
        recent_prices = self.price_history[-self.divergence_lookback:]

        # Find price peaks and troughs
        price_trend = self._calculate_trend(recent_prices)
        macd_trend = self._calculate_trend([m.macd_line for m in recent_macd])

        # Check for divergence
        if price_trend > 0 and macd_trend < 0:
            # Bearish divergence (price up, MACD down)
            strength = abs(price_trend - macd_trend) / 2
            confidence = min(strength * 2, 1.0)

            return TrendSignal(
                signal_type='sell',
                strength=strength,
                confidence=confidence,
                timestamp=recent_macd[-1].timestamp,
                price=current_price,
                macd_values=recent_macd[-1],
                conditions={
                    'bearish_divergence': True,
                    'price_trend_up': price_trend > 0,
                    'macd_trend_down': macd_trend < 0,
                },
            )

        elif price_trend < 0 and macd_trend > 0:
            # Bullish divergence (price down, MACD up)
            strength = abs(price_trend - macd_trend) / 2
            confidence = min(strength * 2, 1.0)

            return TrendSignal(
                signal_type='buy',
                strength=strength,
                confidence=confidence,
                timestamp=recent_macd[-1].timestamp,
                price=current_price,
                macd_values=recent_macd[-1],
                conditions={
                    'bullish_divergence': True,
                    'price_trend_down': price_trend < 0,
                    'macd_trend_up': macd_trend > 0,
                },
            )

        return None

    def _detect_momentum_change(
        self,
        current: MACDValues,
        price: float,
    ) -> Optional[TrendSignal]:
        """Detect significant momentum changes."""
        if len(self.macd_history) < 3:
            return None

        # Calculate momentum change
        recent_histograms = [m.histogram for m in self.macd_history[-3:]]
        momentum_change = recent_histograms[-1] - recent_histograms[-3]

        if abs(momentum_change) >= self.momentum_threshold:
            signal_type = 'buy' if momentum_change > 0 else 'sell'
            strength = min(abs(momentum_change), 1.0)
            confidence = strength * 0.7  # Lower confidence for momentum signals

            return TrendSignal(
                signal_type=signal_type,
                strength=strength,
                confidence=confidence,
                timestamp=current.timestamp,
                price=price,
                macd_values=current,
                conditions={
                    'momentum_change': True,
                    'significant_change': abs(momentum_change) >= self.momentum_threshold,
                    'momentum_direction': 'positive' if momentum_change > 0 else 'negative',
                },
            )

        return None

    def _calculate_crossover_confidence(self, macd: MACDValues, direction: str) -> float:
        """Calculate confidence for crossover signals."""
        base_confidence = 0.6

        # Increase confidence based on distance from zero
        zero_distance_factor = min(abs(macd.macd_line), 1.0) * 0.2

        # Increase confidence based on histogram strength
        histogram_factor = min(abs(macd.histogram), 1.0) * 0.2

        return min(base_confidence + zero_distance_factor + histogram_factor, 1.0)

    def _calculate_zero_crossover_confidence(self, macd: MACDValues, direction: str) -> float:
        """Calculate confidence for zero crossover signals."""
        base_confidence = 0.7

        # Increase confidence based on signal line position
        signal_factor = 0.0
        if direction == 'bullish' and macd.signal_line < 0:
            signal_factor = 0.2
        elif direction == 'bearish' and macd.signal_line > 0:
            signal_factor = 0.2

        return min(base_confidence + signal_factor, 1.0)

    def _calculate_trend(self, values: List[float]) -> float:
        """Calculate trend direction from values."""
        if len(values) < 2:
            return 0.0

        # Simple linear regression slope
        n = len(values)
        x_sum = sum(range(n))
        y_sum = sum(values)
        xy_sum = sum(i * values[i] for i in range(n))
        x2_sum = sum(i * i for i in range(n))

        if n * x2_sum - x_sum * x_sum == 0:
            return 0.0

        slope = (n * xy_sum - x_sum * y_sum) / (n * x2_sum - x_sum * x_sum)
        return slope


class MACDAnalyzer:
    """
    Multi-timeframe MACD trend analysis engine.

    Features:
    - Multi-timeframe analysis
    - Real-time signal generation
    - Trend strength calculation
    - Signal aggregation and weighting
    - Performance monitoring
    """

    def __init__(self, settings: Settings):
        self.settings = settings
        self.buffer_manager = get_buffer_manager()
        self.event_publisher = get_event_publisher()
        self.task_manager = get_task_manager()

        # MACD configurations for different timeframes
        self.timeframes = ['M1', 'M3', 'M5', 'M15', 'H1']
        self.macd_configs = {
            timeframe: MACDConfig() for timeframe in self.timeframes
        }

        # MACD calculators per symbol and timeframe
        self.calculators: Dict[str, Dict[str, MACDCalculator]] = defaultdict(lambda: {})
        self.signal_generators: Dict[str, Dict[str, MACDSignalGenerator]] = defaultdict(lambda: {})

        # Analysis state
        self.active_symbols: Set[str] = set()
        self.is_running = False
        self.analysis_lock = threading.RLock()

        # Signal subscribers
        self.signal_subscribers: Dict[str, Set[Callable]] = defaultdict(set)

        # Performance metrics
        self.metrics = {
            'signals_generated': 0,
            'analyses_performed': 0,
            'processing_time_ms': deque(maxlen=1000),
            'timeframes_analyzed': len(self.timeframes),
        }

        logger.info(f"MACD analyzer initialized for timeframes: {self.timeframes}")

    async def start_analysis(self, symbols: List[str]) -> None:
        """
        Start MACD analysis for specified symbols.

        Args:
            symbols: List of symbols to analyze
        """
        if self.is_running:
            logger.warning("MACD analysis already running")
            return

        try:
            self.is_running = True

            # Initialize analyzers for each symbol
            for symbol in symbols:
                await self._initialize_symbol_analysis(symbol)

            # Subscribe to OHLC data updates
            for symbol in symbols:
                for timeframe in self.timeframes:
                    buffer = self.buffer_manager.get_ohlc_buffer(symbol, timeframe)
                    if buffer:
                        buffer.subscribe_to_bars(symbol, timeframe, self._process_ohlc_update)

            self.active_symbols.update(symbols)

            # Start periodic analysis task
            self.task_manager.submit_recurring_task(
                name="macd_trend_analysis",
                func=self._perform_trend_analysis,
                interval=5.0,  # Every 5 seconds
                priority=self.settings.mt5.performance.max_response_latency,
            )

            logger.info(f"Started MACD analysis for {len(symbols)} symbols")

        except Exception as e:
            self.is_running = False
            logger.error(f"Failed to start MACD analysis: {e}")
            raise

    async def stop_analysis(self) -> None:
        """Stop MACD analysis."""
        if not self.is_running:
            return

        try:
            self.is_running = False

            # Clear state
            self.calculators.clear()
            self.signal_generators.clear()
            self.active_symbols.clear()
            self.signal_subscribers.clear()

            logger.info("Stopped MACD analysis")

        except Exception as e:
            logger.error(f"Error stopping MACD analysis: {e}")

    async def _initialize_symbol_analysis(self, symbol: str) -> None:
        """Initialize MACD analysis for a symbol."""
        for timeframe in self.timeframes:
            config = self.macd_configs[timeframe]

            # Create calculator
            self.calculators[symbol][timeframe] = MACDCalculator(config)

            # Create signal generator
            self.signal_generators[symbol][timeframe] = MACDSignalGenerator(config)

        logger.debug(f"Initialized MACD analysis for {symbol}")

    def _process_ohlc_update(self, ohlc: OHLCData) -> None:
        """Process OHLC update and calculate MACD."""
        if not self.is_running:
            return

        start_time = time.perf_counter()

        try:
            with self.analysis_lock:
                symbol = ohlc.symbol
                timeframe = ohlc.timeframe

                # Get calculator and signal generator
                calculator = self.calculators[symbol].get(timeframe)
                signal_generator = self.signal_generators[symbol].get(timeframe)

                if not calculator or not signal_generator:
                    return

                # Update MACD calculation
                macd_values = calculator.update(float(ohlc.close), ohlc.timestamp)
                if not macd_values:
                    return

                # Check for signal generation
                previous_macd = None
                if len(signal_generator.macd_history) > 0:
                    previous_macd = signal_generator.macd_history[-1]

                signal = signal_generator.analyze_signal(
                    current_macd=macd_values,
                    current_price=float(ohlc.close),
                    previous_macd=previous_macd,
                )

                if signal:
                    self.metrics['signals_generated'] += 1
                    asyncio.create_task(self._handle_signal(symbol, timeframe, signal))

                self.metrics['analyses_performed'] += 1

        except Exception as e:
            logger.error(f"Error processing OHLC update for {ohlc.symbol}: {e}")

        finally:
            processing_time = (time.perf_counter() - start_time) * 1000
            self.metrics['processing_time_ms'].append(processing_time)

    async def _handle_signal(self, symbol: str, timeframe: str, signal: TrendSignal) -> None:
        """Handle generated MACD signal."""
        try:
            # Create trend analysis object
            trend_analysis = TrendAnalysis(
                symbol=symbol,
                timeframe=timeframe,
                timestamp=signal.timestamp,
                trend=TrendDirection.BULLISH if signal.signal_type == 'buy' else (
                    TrendDirection.BEARISH if signal.signal_type == 'sell' else TrendDirection.NEUTRAL
                ),
                strength=signal.strength,
                confidence=signal.confidence,
                macd_line=signal.macd_values.macd_line,
                signal_line=signal.macd_values.signal_line,
                histogram=signal.macd_values.histogram,
                buy_signal=signal.signal_type == 'buy',
                sell_signal=signal.signal_type == 'sell',
            )

            # Notify subscribers
            key = f"{symbol}:{timeframe}"
            for callback in self.signal_subscribers.get(key, set()):
                try:
                    callback(trend_analysis)
                except Exception as e:
                    logger.error(f"Error in signal subscriber callback: {e}")

            # Publish event
            from core.data.models import MarketEvent, MarketEventType
            import uuid

            event = MarketEvent(
                event_id=str(uuid.uuid4()),
                event_type=MarketEventType.TREND_CHANGE,
                symbol=symbol,
                data={
                    'timeframe': timeframe,
                    'trend_analysis': trend_analysis.to_dict(),
                    'signal': signal.to_dict(),
                }
            )

            await self.event_publisher.publish(event)

            logger.debug(
                f"Generated {signal.signal_type} signal for {symbol} {timeframe}: "
                f"strength={signal.strength:.2f}, confidence={signal.confidence:.2f}"
            )

        except Exception as e:
            logger.error(f"Error handling MACD signal: {e}")

    async def _perform_trend_analysis(self) -> None:
        """Perform comprehensive trend analysis across timeframes."""
        try:
            for symbol in list(self.active_symbols):
                trend_summary = await self._analyze_symbol_trend(symbol)
                if trend_summary:
                    logger.debug(f"Trend summary for {symbol}: {trend_summary}")

        except Exception as e:
            logger.error(f"Error in trend analysis: {e}")

    async def _analyze_symbol_trend(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Analyze overall trend for a symbol across timeframes."""
        try:
            timeframe_trends = {}
            total_strength = 0.0
            total_confidence = 0.0
            signal_counts = {'buy': 0, 'sell': 0, 'hold': 0}

            for timeframe in self.timeframes:
                signal_gen = self.signal_generators[symbol].get(timeframe)
                if not signal_gen or not signal_gen.signal_history:
                    continue

                # Get latest signal
                latest_signal = signal_gen.signal_history[-1]
                timeframe_trends[timeframe] = latest_signal.to_dict()

                # Aggregate metrics
                total_strength += latest_signal.strength
                total_confidence += latest_signal.confidence
                signal_counts[latest_signal.signal_type] += 1

            if not timeframe_trends:
                return None

            # Calculate overall trend
            avg_strength = total_strength / len(timeframe_trends)
            avg_confidence = total_confidence / len(timeframe_trends)

            # Determine overall signal
            dominant_signal = max(signal_counts.items(), key=lambda x: x[1])[0]

            return {
                'symbol': symbol,
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'overall_trend': dominant_signal,
                'average_strength': avg_strength,
                'average_confidence': avg_confidence,
                'timeframe_trends': timeframe_trends,
                'signal_distribution': signal_counts,
            }

        except Exception as e:
            logger.error(f"Error analyzing trend for {symbol}: {e}")
            return None

    def subscribe_to_signals(
        self,
        symbol: str,
        timeframe: str,
        callback: Callable[[TrendAnalysis], None],
    ) -> None:
        """Subscribe to MACD signals for specific symbol and timeframe."""
        key = f"{symbol}:{timeframe}"
        self.signal_subscribers[key].add(callback)

    def unsubscribe_from_signals(
        self,
        symbol: str,
        timeframe: str,
        callback: Callable[[TrendAnalysis], None],
    ) -> None:
        """Unsubscribe from MACD signals."""
        key = f"{symbol}:{timeframe}"
        self.signal_subscribers[key].discard(callback)

    def get_latest_analysis(self, symbol: str, timeframe: str) -> Optional[TrendSignal]:
        """Get latest MACD analysis for symbol and timeframe."""
        signal_gen = self.signal_generators[symbol].get(timeframe)
        if signal_gen and signal_gen.signal_history:
            return signal_gen.signal_history[-1]
        return None

    def get_metrics(self) -> Dict[str, Any]:
        """Get MACD analyzer metrics."""
        avg_processing_time = (
            sum(self.metrics['processing_time_ms']) / len(self.metrics['processing_time_ms'])
            if self.metrics['processing_time_ms'] else 0.0
        )

        return {
            'is_running': self.is_running,
            'active_symbols': len(self.active_symbols),
            'timeframes_analyzed': self.metrics['timeframes_analyzed'],
            'signals_generated': self.metrics['signals_generated'],
            'analyses_performed': self.metrics['analyses_performed'],
            'avg_processing_time_ms': avg_processing_time,
            'symbols': list(self.active_symbols),
        }

    async def health_check(self) -> Dict[str, Any]:
        """Perform health check on MACD analyzer."""
        health = {
            'status': 'healthy' if self.is_running else 'stopped',
            'is_running': self.is_running,
            'active_symbols': len(self.active_symbols),
            'signals_per_minute': 0.0,
        }

        # Calculate signal rate
        if self.is_running and self.metrics['signals_generated'] > 0:
            # Estimate based on recent activity
            health['signals_per_minute'] = self.metrics['signals_generated'] / max(1, time.time() / 60)

        return health


# Global MACD analyzer instance
_macd_analyzer: Optional[MACDAnalyzer] = None


def get_macd_analyzer() -> MACDAnalyzer:
    """Get the global MACD analyzer instance."""
    global _macd_analyzer

    if _macd_analyzer is None:
        from core.config.settings import Settings
        settings = Settings()
        _macd_analyzer = MACDAnalyzer(settings)

    return _macd_analyzer